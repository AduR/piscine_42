#!/usr/bin/env bash

# export or not export -> http://unix.stackexchange.com/questions/107851/using-export-in-bashrc

#set -u # exit when your script tries to use undeclared variables

# Fix undefined variables
VIRTUAL_ENV_DISABLE_PROMPT=""
VIRTUAL_ENV=""

#
# Set title of terminal, used by PS1 and some alias
#

set_xtitle () {
    case "$TERM" in
        *term* | rxvt)
            echo -en "\033]0;$@\007"
            ;;
        *)
            ;;
    esac
}

#
# Color definitions - for fancy prompt PS1 or colored man
#

# Normal Colors
Black='\e[0;30m'
Red='\e[0;31m'
Green='\e[0;32m'
Yellow='\e[0;33m'
Blue='\e[0;34m'
Purple='\e[0;35m'
Cyan='\e[0;36m'
White='\e[0;37m'

# Bold
BBlack='\e[1;30m'
BRed='\e[1;31m'
BGreen='\e[1;32m'
BYellow='\e[1;33m'
BBlue='\e[1;34m'
BPurple='\e[1;35m'
BCyan='\e[1;36m'
BWhite='\e[1;37m'

# Background
On_Black='\e[40m'
On_Red='\e[41m'
On_Green='\e[42m'
On_Yellow='\e[43m'
On_Blue='\e[44m'
On_Purple='\e[45m'
On_Cyan='\e[46m'
On_White='\e[47m'

# Color Reset
NC="\e[m"

#
# Colored man
#

# mb start blink
# md start bold
# me turn off bold, blink and underline
# so start standout (reverse video)
# se stop standout
# us start underline
# ue stop underline

export LESS_TERMCAP_mb=$'\E[0m'
export LESS_TERMCAP_md=$'\E[0;32m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_so=$'\E[0;31m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_us=$'\E[0;34m'
export LESS_TERMCAP_ue=$'\E[0m'

#
# Fancy prompt PS1
#

_ps1_update () {
    local last_cmd_ret="$?"  # must be first

    local tmp
    local user_hostname
    PS1=""
    user_hostname="${USER}@${HOSTNAME}"

    # window title
    set_xtitle "${USER}@${HOSTNAME%%.*}:${PWD/#$HOME/\~}"

    # virtual env
    if [ -z "$VIRTUAL_ENV_DISABLE_PROMPT" ];
    then
        virtual_env=$(basename "$VIRTUAL_ENV")
        if [ "$virtual_env" != "" ];
        then
            PS1+="($virtual_env) "
        fi
    fi

    # date
    PS1+="${Cyan}\t${NC} "

    # login + hostname
    if [[ "$user_hostname" = "nodraak@macbian8" ]]; then
        PS1+="${Green}$user_hostname${NC} "
    elif [[ "$user_hostname" = "nodraak@diamant" ]]; then
        PS1+="${Cyan}$user_hostname${NC} "
    else
        PS1+="${Red}$user_hostname${NC} "
    fi

    # git
    if [[ "$(type -t __git_ps1)" = "" ]]; then
        PS1+="${Red}gitPS1NotFound${NC} "
    else
        tmp="$(__git_ps1 "[%s]")"
        if [[ -n "$tmp" ]]; then
            PS1+="${Yellow}$tmp${NC} "
        fi
    fi

    # last cmd ret
    if [[ "$last_cmd_ret" != "0" ]]; then
        PS1+="${Red}$last_cmd_ret${NC} "
    fi

    # cwd
    PS1+="${Blue}\w${NC} "

    # finally, new line + user/root prompt
    PS1+="\n\\$ "

    # no "export PS1" needed
}

PROMPT_COMMAND="_ps1_update"

export GIT_PS1_SHOWDIRTYSTATE=1
export GIT_PS1_SHOWUPSTREAM="auto verbose git"

#
# Aliases
#

# clipboard
alias pbcopy='xsel --clipboard --input'
alias pbpaste='xsel --clipboard --output'

# basic cmd
alias ls='ls --color'
alias ll='ls -lGh'
alias la='ls -lGha'
alias lla='la'
alias grep='grep --color'
alias du='du -kh'
alias df='df -khT'

# more advanced cmd
alias c='clear'
alias py='python3'
alias ipy='ipython3'
alias v="vim"
alias diff='colordiff'
alias vd='vimdiff'

# dev
alias g='git'  # now this is what I call 'lazy'
complete -o default -o nospace -F _git g
source /usr/share/bash-completion/completions/git
alias gg='gitg'
alias gg.='gg .'
alias gcc='gcc -fdiagnostics-color=auto'
alias disas='objdump -D -F -M intel'
alias disasArm='arm-none-eabi-objdump -D -F -M intel'

# dev - techno specific utils
alias sba='source ../bin/activate'
alias cc='compass compile'
complete -o nospace -F _filedir_xspec cc
alias pmr='python manage.py runserver'
alias pylint='pylint3 --comment=y'
complete -o nospace -F _filedir_xspec pylint
alias pylintd='pylint3 --load-plugins pylint_django'

# dual monitor
alias dmen='xrandr --output DP1 --above LVDS1 --auto'
alias dmdis='xrandr --output DP1 --off'

# misc
alias pdflatex='pdflatex -file-line-error -halt-on-error'
HISTIGNORE='jrnl *'  # no export needed
bind Space:magic-space  # expand !!, ^old^new, etc

alias sl='sl -e'
alias tmux='TERM=screen-256color tmux'  # keep vim's user defined theme
alias dmesg=' dmesg -dTw'

alias ports='netstat -tulanp'
alias getlyrics='kid3-cli -c "get comment" "$(mocp --info | grep File | cut -b 7-)"'


#
# Env variables
#

export EDITOR="vim"  # for git, crontab, ...

export GOPATH=~/gopath
export PATH=$GOPATH:$GOPATH/bin:${PATH}
export DRIVE_GOMAXPROCS=8

export GCCARMPATH=/home/nodraak/Documents/Etudes/ECE_ING4/Deoxys/stm32-mbed/gcc-arm-none-eabi-5_4-2016q2/bin
export PATH=$GCCARMPATH:${PATH}

#
# Functions
#

cvg () {
    coverage erase
    echo "Starting tests ..."
    coverage run ./manage.py test
    echo "Generating html report ..."
    coverage html
}

_texspell_file() {
    if [ $# -ne 4 ]
    then
        echo "Usage: _texspell <lang> <file> <extradict> <localdict>"
        return 1
    fi

    lang=$1
    file=$2
    extradict=$3
    localdict=$4

    for word in $(aspell --lang="$lang" --mode=tex "$extradict" "$localdict" list < "$file" | sort | uniq)
    do
        echo "$word"
        #echo "== $word =="
        #grep --with-filename --line-number " $word " "$file"
    done
}

texspell () {
    # args

    if [ $# -ne 2 ]
    then
        echo "Usage: texspell <lang> <file or dir>"
        return 0
    fi

    lang="$1"
    file_or_dir="$2"

    # options

    extradict=""
    localdict=""
    if [ -f "/usr/lib/aspell/custom_${lang}.rws" ]
    then
        echo "Using extra dic \"custom_${lang}.rws\""
        extradict="--extra-dicts=custom_${lang}.rws"
    fi
    if [ -f "./aspell_dict.txt" ]
    then
        echo "Using personal dict \"./aspell_dict.txt\""
        localdict="--personal=./aspell_dict.txt"
    fi

    # now spell checking

    if [ -d "$file_or_dir" ]
    then
        echo "Spell checking all .tex files in folder $file_or_dir"
        for f in $(find "$file_or_dir" | grep "\.tex$")
        do
            _texspell_file "$lang" "$f" "$extradict" "$localdict"
        done
    fi

    if [ -f "$file_or_dir" ]
    then
        echo "Spell checking file $file_or_dir"
        _texspell_file "$lang" "$file_or_dir" "$extradict" "$localdict"
    fi
}

#texdic () {
#    sudo aspell --lang=en create master /usr/lib/aspell/custom_en.rws < ./dic.txt
#}

o () {
    local cmd

    if [[ $# -eq 0 ]]; then
        echo 'Error: argument expected.'
        return 1
    fi

    file -E "$1"
    if [[ $?  -ne 0 ]]; then
        echo 'Error: File not found.'
        return 2
    fi

    cmd=""

    case $1 in
        *.png|*.jpg|*.jpeg )
            cmd="eog"
            ;;
        *.mp3|*.flac|*.mp4|*.mkv|*.avi )
            cmd="vlc"
            ;;
        *.pdf )
            #cmd="evince"
            cmd="zathura"
            ;;
        *.txt|*.md|*.tex|*.c|*.h|*.py|*.css|*.scss|*.js|*.json|*.sh )
            cmd="sublime"
            ;;
        *.html )
            cmd="firefox"
            ;;
        * )
            if [ $# -eq 1 ]; then
                case $1 in
                    *.tar.bz2)  cmd="tar xvjf"      ;;
                    *.tar.gz)   cmd="tar xvzf"      ;;
                    *.bz2)      cmd="bunzip2"       ;;
                    *.rar)      cmd="unrar x"       ;;
                    *.gz)       cmd="gunzip"        ;;
                    *.tar)      cmd="tar xvf"       ;;
                    *.tbz2)     cmd="tar xvjf"      ;;
                    *.tgz)      cmd="tar xvzf"      ;;
                    *.zip)      cmd="unzip"         ;;
                    *.Z)        cmd="uncompress"    ;;
                    *.7z)       cmd="7z x"          ;;
                esac
            fi
            ;;
    esac

    if [[ "$cmd" = "" ]]; then
        echo Error: unknown extension, using pcmanfm for opening "$@"
        cmd="pcmanfm"
    fi

    exec $cmd "$@" &
}
complete -o nospace -F _filedir_xspec o

whereispylib () {
    for lib in "$@"
    do
        py -c "
try:
    import $lib
    try:
        if len($lib.__path__) == 1:
            print($lib.__path__[0])
        else:
            print($lib.__path__)
    except AttributeError:
        print('$lib is a built-in module')
except ImportError:
    print('$lib is not installed')
"

    done
}

prettyjson() {
    python -m json.tool "$@" | pygmentize -l javascript
}

grepdf () {
    if [ $# -ne 2 ] && [ $# -ne 3 ]; then
        echo "Usage: grepdf <pattern> <path> [<grep opt>]"
        return 0
    fi

    pattern=$1
    path=$2
    grepopt=""
    if [ $# -eq 3 ]; then
        grepopt=$3
    fi

    find_cmd="pdftotext -q '{}' - | grep $grepopt --with-filename --label='{}' --color \"$pattern\""
    find "$path" -name "*.pdf" -exec sh -c "$find_cmd" \;
}

pdf_extract_page() {
    if [ $# -ne 4 ]
    then
        echo "usage: ./script infile outfile start stop"
        return 1
    fi

    INFILE=$1
    OUTFILE=$2
    START=$3
    STOP=$4

    gs -sDEVICE=pdfwrite -dNOPAUSE -dSAFER -dFirstPage="$START" -dLastPage="$STOP" -sOutputFile="$OUTFILE" "$INFILE"
}

airdroid_proxy () {
    mitmproxy -s test_mtimproxy.py -R https://192.168.87.101:8890/ -b 127.0.0.1 -p 8080
}


#
# Tmp / unused stuff (to be deleted at the end of the year)
#


alias youtube-dl-audio="youtube-dl --extract-audio --format 140"


#
# Finally, stuff that prints something
#

# Start tmux on every shell login
#[[ $- != *i* ]] && return  # If not running interactively, do not do anything
#[[ -z "$TMUX" ]] && TERM=screen-256color exec tmux

# linuxlogo

# Makes our day a bit more fun !
# if [ -x /usr/games/fortune ]; then
#     /usr/games/fortune -s | cowsay
# fi
